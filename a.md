#我的天啊
**我是天才**
*我是天才*
~~我是天才~~
>我是天才
***
![img]()
[超链接名](地址)
|表头1|表头2|表头3|
|-----|:--:|----:|
|单元格|单元格|单元格|
|单元格|单元格|单元格|
第二行分割表头和内容

第二行减号有一个就行，多加几个也无所谓

单元格文字默认居左

第二行减号两边加冒号，表示单元格文字居中

第二行减号右边加冒号，表示文字居右
- 列表内容
或

+ 列表内容
或

* 列表内容
注意- + * 和列表内容之间都要有一个空格
#static的注意事项：
##A:在静态方法中是没有this关键字的
			因为静态是随着类的加载而加载，优先于对象而存在。而this是随着对象的创建而存在。
			先进内存的， 不能访问后进内存的；而后进内存的，可以访问先进内存的。
##B:静态只能访问静态。
			非静态的成员方法：
				可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法
			静态的成员方法：
				只能访问静态的成员变量，静态的成员方法
   
###1:继承(掌握)
	(1)把多个类中相同的属性和行为提取出来，定义到一个类中，
	   然后让这多个类和这一个类产生一个关系，这多个类就具备这一个类的属性和行为了。
	   这种关系叫：继承。
	(2)继承如何表示的呢?
		格式：class 子类名 extends 父类名 {}
	(3)java中的继承特点：
		A:java中只能单继承
		B:java中可以多层继承。(继承体系)
	(4)java中的继承的好处和弊端
		A:好处	
			a:提高了代码的复用性
			b:提高了代码的可维护性
			c:让类与类之间产生了一个关系，是多态的前提
		B:弊端
			让类与类的耦合增强了。这样一个类的改动会直接影响另一个类。

			设计原则：高内聚，低耦合。
	(5)java中的继承的注意事项：
		A:私有成员不能被继承
		B:构造方法不能被继承，想访问，通过super关键字
		C:不能为了部分功能而去使用继承
	(6)继承中的成员关系：
		A:成员变量
			不同名：特别简单，一看就知道用的是谁。
			同名：就近原则
				访问自己的用this
				访问父亲的用super
		B:构造方法
			a:子类的所有构造方法默认都是访问父类的无参构造方法
			b:如果父类没有无参构造方法，怎么办呢?
				通过super(...)访问父类带参构造方法
				通过this(...)访问本类其他构造方法。(一定要有一个访问了父类的构造方法)
				注意：super或者this只能出现一个，并且只能在语句的第一条语句。
			为什么呢?
				因为子类可能会访问父类的数据，所以，在子类初始化之前，要先把父类数据初始化完毕。
		C:成员方法
			不同名：特别简单，一看就知道用的是谁。
			同名：就近原则
				访问自己的用this
				访问父亲的用super
	(7)this和super的区别及应用场景
		A:区别
			this：本类对象的引用
			super：父类存储空间的标识。可以理解为父类对象的引用。

		B:应用场景
			a:成员变量
				this.变量 本类的成员变量
				super.变量 父类的成员变量
			b:构造方法
				this(...) 本类的构造方法
				super(...) 父类的构造方法
			c:成员方法
				this.方法名(...) 本类的成员方法
				super.方法名(...) 父类的成员方法
	(8)练习：
		老师类和学生类练习：
			继承前：
			继承后：
		猫类和狗类练习：
			继承前：
			继承后：

####2:方法重写(掌握)
	(1)描述：在子类中，出现了和父类中一模一样的方法声明的现象。
	(2)作用：可以使用父类功能，还可以增强该功能。
	(3)面试题：
		override和overload的区别?
		overload可以改变返回值类型吗?
	(4)方法重写的注意事项：
		A:父类私有方法不能被重写
		B:子类重写方法的访问权限不能比父类的方法低
		C:静态只能重写静态。(其实这算不上重写)

####3:final关键字(掌握)
	(1)final:最终的意思
	(2)作用：可以修饰类，修饰成员变量，修饰成员方法
	(3)特点：
		A:修饰类 类不能被继承
		B:修饰成员变量 变量变成了常量
		C:修饰成员方法 方法不能被重写
	(4)面试题：
		A:final修饰局部变量
			a:基本类型 值不能发生改变
			b:引用类型 地址值不能发送改变，对象的内容是可以改变的
		B:final的初始化时机
			a:在定义时就赋值
			b:在构造方法完毕前赋值

####4:多态(掌握)
<font face="楷体">(1)多态：同一个对象，在不同时刻表现出来的多种状态
		举例：水，猫和动物
	(2)多态的前提：
		A:有继承关系
		B:有方法重写
		C:有父类引用指向子类对象
	(3)多态中的成员访问特点：
		A:成员变量
			编译看左边，运行看左边
		B:成员方法
			编译看左边，运行看右边
		C:静态方法
			编译看左边，运行看左边
		为什么：
			因为方法有重写，而变量没有。静态方法没有重写一说。            </font>
多态的好处：
1.提高了程序的维护性（由继承来保证）
2.提高了程序的扩展性（由多态保证）
弊端：
不能访问子类的特有功能
####多态中的引用类型转换
1、向上类型转换(自动/隐式类型转换)，是小类型转化成大类型，不存在认了风险。即子类型对象也是父类型。
2、向下类型转化(强制类型转化)，大类型转化成小类型，存在一定风向。多态实例后，都可以向上类型转化，但是转化后，子类型对象间的互相转换就会存在一定风险。
####抽象类：
抽象类概述：动物不是一个具体的事物，只有猫，狗才是具体的个体。
				并且，在动物中我们针对吃的功能，也不应该给出具体的体现，
				因为不同的动物吃的内容是不一样的，我们应该让具体的动物自己去实现自己吃的功能。
				而一个功能如果没有具体的体现，就是一个抽象的内容。如何表示呢?
				格式：
					修饰符 返回值类型 方法名(参数列表...);
				为了表示这是一个抽象的东西，java提供了一个标识的关键字：abstract
				格式：
					修饰符 abstract 返回值类型 方法名(参数列表...);
				而一个类中的方法如果是抽象的类，那么，该类就必须定义为抽象类。
	抽象类的特点：
		A:抽象类和抽象方法必须用abstract关键字修饰
		B:抽象类的子类
			a:要么是抽象类
			b:要么重写抽象类中的所有抽象方法
		C:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类
		D:抽象类不能实例化
			那么如何使用抽象类的功能呢?
			按照多态的方式使用。抽象类多态。
	回顾：
		多态前提为什么要有方法重写呢?
			因为父类的方法可能是抽象的。
		抽象类的成员特点：
		A:成员变量
			可以是变量，也可以是常量
		B:构造方法
			有构造方法。但是不能实例化。
			问题：构造方法有什么用呢?
				用于子类访问父类数据的初始化
		C:成员方法
			可是有抽象方法，也可以有非抽象方法。
			抽象方法：强制要求子类做某些事情。
			非抽象方法：用于给子类直接使用，提高了代码的复用性。
abstract不能和哪些关键字共存
		final: final修饰的方法不能被重写，而abstract修饰的方法要求必须被重写。
		private：private修饰的方法不能被重写，而abstract修饰的方法要求必须被重写。
	
static：static修饰的方法可以通过类名调用，而abstract修饰的方法是没有方法体的，
调用一个没有方法体的方法是没有任何意义的，所以不能共存。